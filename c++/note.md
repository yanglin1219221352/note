1、c++ 中虚基类是为了消除二义性，强调这个类型某些方法没有意义，只是为了继承，不要构造这种函数。
2、ios 是抽象基类 派生出了istream和ostream类 iostream是多重继承了istream和ostream来的。
3、在多重继承情况下可能会产生基类命名相同的情况，需要显式指明使用的哪个类成员(即加上域名和作用域解析符::) 以消除二义性。
4、char b=0 ; int a=0; b>a == false; 其中b会强制转化为(int)0 所以b>a为false; 但如果 b='0'则比较时会转化成ascii码即48. 应该是>重载了。
5、引用是除指针外另一个可以产生多态效果的手段，一个基类的引用可以指向它的派生类实例。
6、构造函数和析构函数都没有返回值！！！！
7、拷贝构造函数为什么用引用：因为如果使用传值的话会产生循环嵌套（传值的时候会自动使用拷贝构造函数）
8、const函数用途:
    1）可以定义const常量
    2）便于进行类型检查：const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误
    3）可以保护被修饰的东西 ：防止意外的修改，增强程序的健壮性。
    4）可以节省空间，避免不必要的内存分配：const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝
    5）	提高了编译效率:编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高
9、static函数用途:
    1）全局静态变量{
        内存中的位置：静态存储区，整个程序运行的过程都在
        初始化：未初始化的全局变量会自动初始化为0
        作用域：全局静态变量在生命他的文件之外是不可见的
    }
    2）局部静态变量{
        内存中的位置：静态存储区
        初始化：未经初始化的局部变量会自动初始化为0
        作用域：局部作用域，离开作用域后未被销毁，但不能对其访问
    }
    3）静态函数{
        仅本文件可以使用，所以不要在头文件使用static全局函数
        不要在cpp内声明非static的全局函数（不知道原因）
        如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
    }
    4）类的静态成员{
        在类中保证多个对象之间的数据共享，并且静态成员函数不会破坏隐藏的规则，保证安全性。
        静态成员函数只保存一处，共所有对象使用。
        静态数据成员的初始化格式：<数据类型><类名>::<静态数据成员名>=<值>
        类的静态数据成员有两种访问方式：<类对象名>.<静态数据成员名> 或 <类类型名>::<静态数据成员名>
    }
    5）类的静态函数{
        没有this指针。无法访问非静态成员函数。
        静态成员函数和静态数据成员一样，它们都是与类的静态成员，它们都不是对象成员。因此，对静态成员引用不需要用对象名。
        在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员.如果静态成员函数中要引用非静态成员时，可通过对象来引用。
        从中可看出，调用静态成员函数使用格式如下 <类名>::<静态成员函数名>(<参数表>);
        对比 ：非静态成员函数可以任意地访问静态成员函数和静态数据成员
    }
10、在类中如不做特别声明，成员数据和成员函数均默认未private。在结构体中默认为public。
11、隐藏、重写、重载的区别：
12、inline函数：
13、指针和引用的区别：
    1）指针可以为空，引用不能为空。
    2）指针可以改变指向，引用不能改变指向。
    3）指针可以有多级，引用只能有一级
    4）指针定义时可以不初始化，引用定义时可以初始化。
    5）sizeof引用得到的是所指向的变量(对象)的大小，sizeof指针得到的是指针本身的大小。
    6）在函数传递过程中传指针其实也是传值（传了一个地址的值），传引用传的是自己。
14、纯虚函数：virtual 函数类型 函数名（参数表）=0；  

