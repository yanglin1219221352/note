1、c++ 中虚基类是为了消除二义性，强调这个类型某些方法没有意义，只是为了继承，不要构造这种函数。
2、ios 是抽象基类 派生出了istream和ostream类 iostream是多重继承了istream和ostream来的。
3、在多重继承情况下可能会产生基类命名相同的情况，需要显式指明使用的哪个类成员(即加上域名和作用域解析符::) 以消除二义性。
4、char b=0 ; int a=0; b>a == false; 其中b会强制转化为(int)0 所以b>a为false; 但如果 b='0'则比较时会转化成ascii码即48. 应该是>重载了。
5、引用是除指针外另一个可以产生多态效果的手段，一个基类的引用可以指向它的派生类实例。
6、构造函数和析构函数都没有返回值！！！！
7、拷贝构造函数为什么用引用：因为如果使用传值的话会产生循环嵌套（传值的时候会自动使用拷贝构造函数）
8、const函数用途:
9、static函数用途:
    1）全局静态变量{
        内存中的位置：静态存储区，整个程序运行的过程都在
        初始化：未初始化的全局变量会自动初始化为0
        作用域：全局静态变量在生命他的文件之外是不可见的
    }
    2）局部静态变量{
        内存中的位置：静态存储区
        初始化：未经初始化的局部变量会自动初始化为0
        作用域：局部作用域，离开作用域后未被销毁，但不能对其访问
    }
    3）静态函数{
        仅本文件可以使用，所以不要在头文件使用static全局函数
        不要在cpp内声明非static的全局函数（个人认为是麻烦和容易导致函数冲突的原因）
        如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
    }
    4）类的静态成员{
        在类中保证多个对象之间的数据共享，并且静态成员函数不会破坏隐藏的规则，保证安全性。
        静态成员函数只保存一处，共所有对象使用。
        静态数据成员的初始化格式：<数据类型><类名>::<静态数据成员名>=<值>
        类的静态数据成员有两种访问方式：<类对象名>.<静态数据成员名> 或 <类类型名>::<静态数据成员名>
    }
    5）类的静态函数{
        没有this指针。无法访问非静态成员函数。
        静态成员函数和静态数据成员一样，它们都是与类的静态成员，它们都不是对象成员。因此，对静态成员引用不需要用对象名。
        在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员.如果静态成员函数中要引用非静态成员时，可通过对象来引用。
        从中可看出，调用静态成员函数使用格式如下 <类名>::<静态成员函数名>(<参数表>);
        对比 ：非静态成员函数可以任意地访问静态成员函数和静态数据成员
    }
10、在类中如不做特别声明，成员数据和成员函数均默认未private。在结构体中默认为public。

